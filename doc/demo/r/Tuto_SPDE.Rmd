---
title: "Introduction to SPDE in gstlearn"
author: "gstlearn Team"
date: "2023-07-10"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

<!-- SUMMARY: Perform Estimation and simulations in the framework of SPDE  -->

<!-- CATEGORY: SPDE -->

# Introduction

In this tutorial, we show how to use the API SPDE.
This is a free transcription in R of the python note book *tuto_SPDE*.

## SPDE approach

Lindgren et al. (2011) defined an explicit link between Gaussian fields and Gaussian markov random fields. This  approach is implemented in the SPDE module of $gstlearn$. The random field is a weak solution of some stochastic partial differential equation solved using the finite element method. It follows that the standard tools of Geostatistics, kriging and stochastic simulation, can be rewritten using sparse linear algebra.

The SPDE model represents the domain by a mesh and random field by its values for each mesh cell 
$\mathbf{Z} \sim \mathcal{N}(\mathbf{0,Q^{-1}})$ where the precision matrix $\mathbf{Q = \Sigma^{-1}}$ is sparse. 

The latent vector $\mathbf{Z}$ can be linearly interpolated to:

* the target locations $\mathbf{Y_T = A_g \, Z}$, or 

* the observation locations $\mathbf{Y = A_d \, Z + \tau W}$. 

In the latter case, $\tau$ is the standard deviation of the noise modelling the error of observation and the modelling error. The number of observations is $p$.

In this case, the precision matrix of the vector $\mathbf{(Z, Y_D)}$ is:
$$
  \mathbf{
    \tilde{Q} = \tilde{\Sigma}^{-1}=
      \begin{bmatrix}\mathbf{Q+\tau^{-2}A_d^T A_d} & \mathbf{-\tau^{-2}A_d^T} \\ \mathbf{-\tau^{-2}A_d} & \mathbf{\tau^{-2}I_p} \end{bmatrix}
  } 
$$
From this expression the kriging and the conditional simulation can be derived:
    
* the Kriging of $\mathbf{Z}$ is $E\{\mathbf{Z|Y = y}\} = \tau^{-2}\mathbf{(Q + \tau^{-2}A_d^TA_d)^{-1}A_d^T y}$

* the conditional variance is $Cov\{\mathbf{Z|Y = y}\} = \mathbf{(Q + \tau^{-2}A_d^TA_d)^{-1}}$

* the non conditional simulation is $\mathbf{(S, S_D)\sim \mathcal{N}(0, \tilde{Q}^{-1})}$
        
* the conditional simulation of the latent vector is $\mathbf{S_{|Y=y} = S + \tau^{-2} (Q+ \tau^{-2}A_d^TA_d)^{-1} A_d^T(y - S_D)}$
        
The estimated or simulated latent vector can be linearly interpolated to any target grid.

The latent vector (of length $n$) $\mathbf{Z \sim \mathcal{N}(0, Q^{-1})}$ is defined on the meshing by its sparse
precision matrix $\mathbf{Q = \Sigma^{-1}}$. $\mathbf{Q}$ is factorized by the Cholesky method: $\mathbf{Q = L\, L^{T}}$.

Thus, the Gaussian vector can be rewritten $\mathbf{Z = (L^T)^{-1} \, U}$ with $\mathbf{U \sim \mathcal{N}(0, I_n)}$.

Finally the Gaussian vector collecting the values of the random field at the grid nodes $Y$ 
is achieved by the interpolation of $\mathbf{Z}$ on the mesh $\mathbf{Y_g = A_{g} \, Z}$.

To compute a non conditional simulation on the grid,

0) Compute the projection matrix of the latent vector $\mathbf{Z}$ to the grid/
1) Compute $\mathbf{L}$ the Cholesky decomposition of the sparse precision matrix $\mathbf{Q}$
2) Compute the normal Gaussian vector $\mathbf{U \sim N(0, I_n)}$,
3) Compute the latent vector $\mathbf{Z}$ solving the sparse linear system $\mathbf{L^{T} \, Z = U}$,
4) Compute the interpolation of the latent vector to the target grid $\mathbf{Y_g = A_{g} \, Z}$,

## Initialization of *gstlearn*

```{r intialization, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
library(gstlearn)
library(Matrix)

set.seed(43243)
```

## Parameters of the SPDE model

```{r parameters}
# Data
ndat = 100

# Model
rangev = 0.2
sill = 1.

# parameters of the final grid on [0,1]^2
nx = 200 * c(1,1)
dx = 1/(nx-1)
x0 = c(0,0)

# Types of statistics
opers = EStatOption_fromKeys(c("NUM", "MINI", "MAXI", "MEAN", "STDV"))
```

## Grid definition

```{r grid_definition, echo=TRUE, eval=TRUE}
grid = DbGrid_create(nx,dx,x0)
```

## Model definition

We define a Matern's stationary covariance function.

```{r model_definition, echo=TRUE, eval=TRUE}
model = Model_createFromParam(ECov_MATERN(), param=1,range=rangev,sill=sill)
```


## Observations of the process

We define the observations from the initial non conditional simulation.

```{r input_data, echo=TRUE, eval=TRUE}
dat = Db_create()
err = dat$setColumn(tab = runif(n=ndat), name = "x")
err = dat$setColumn(tab = runif(n=ndat), name = "y")
err = dat$setLocators(names = c("x", "y"), locatorType = ELoc_X(), cleanSameLocator = TRUE)
```

We perform a quick non conditional simulation on the data location, which will serve for conditioning data set.

```{r simu_data, echo=TRUE, eval=TRUE}
err = dat$deleteColumns(names = "Z")
err = simulateSPDE(dbin = NULL, dbout = dat, model = model, 
                   namconv = NamingConvention("Z"))
```

Plotting the data set

```{r plot_simu_data, echo=TRUE, eval=TRUE}
p = plot.init(asp=1) + 
    plot.symbol(dat, nameSize = "Z", col = "red") +
    plot.decoration(xlab = "Easting", ylab = "Northing", title = "Data Set")
plot.end(p)
```

# Using traditional methods

All traditional methods require a neighborhood definition: it will be defined as a *Unique* neighborhood.


```{r eighborhood, echo=TRUE, eval=TRUE}
neighU = NeighUnique()
```

## Kriging

Kriging is computed using the traditional method.

```{r traditional_kriging, echo=TRUE, eval=TRUE}
err = grid$deleteColumns(names = "standardK.*")
err = kriging(dbin = dat, dbout = grid, model = model, neigh = neighU,
              namconv = NamingConvention("standardK"))
```

Plotting the results

```{r plot_kriging_estim, echo=TRUE, eval=TRUE}
p1 = plot.init(asp=1) + plot.raster(grid, name="standardK.Z.estim", palette = "Spectral") +
        plot.symbol(dat, col = "red") + plot.decoration(title = "Estimation")
p2 = plot.init(asp=1) + plot.raster(grid, name="standardK.Z.stdev", palette = "Spectral") +
        plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "St. dev.")
ggarrange(p1, p2, ncol = 2, nrow = 2)
```

# Conditional simulations

The conditional simulation is performed using the traditional technique (turning bands)

```{r cond_simu, echo=TRUE, eval=TRUE}
err = simtub(dbin = dat, dbout = grid, model = model, neigh = neighU, nbsimu = 4, 
             namconv = NamingConvention("standardCD"))
```

Plotting the conditional simulations

```{r plot_cond_simu}
p1 = plot.init(asp=1) + plot.raster(grid, name="standardCD.Z.1", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD1")
p2 = plot.init(asp=1) + plot.raster(grid, name="standardCD.Z.2", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD2")
p3 = plot.init(asp=1) + plot.raster(grid, name="standardCD.Z.3", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD3")
p4 = plot.init(asp=1) + plot.raster(grid, name="standardCD.Z.4", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD4")
ggarrange(p1, p2, p3, p4, ncol = 2, nrow = 2)
```

# Using SPDE

## Non conditional simulations

```{r nc_simu_spde, echo=TRUE, eval=TRUE}
err = grid$deleteColumns(names = "spdeNC.*")
err = simulateSPDE(dbin = NULL, dbout = grid, model = model, nbsimu=4,
                   namconv = NamingConvention("spdeNC"))
```

Plotting the non conditional simulations

```{r plot_nc_simu_spde, echo=TRUE, eval=TRUE}
p1 = plot.init(asp=1) + plot.raster(grid, name="spdeNC.1", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation NC1")
p2 = plot.init(asp=1) + plot.raster(grid, name="spdeNC.2", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation NC2")
p3 = plot.init(asp=1) + plot.raster(grid, name="spdeNC.3", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation NC3")
p4 = plot.init(asp=1) + plot.raster(grid, name="spdeNC.4", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation NC4")
ggarrange(p1, p2, p3, p4, ncol = 2, nrow = 2)
```

## Conditional simulations

```{r cond_simu_spde, echo=TRUE, eval=TRUE}
err = grid$deleteColumns(names = "spdeCD.*")
err = simulateSPDE(dbin = dat, dbout = grid, model = model, nbsimu=4, 
                   namconv = NamingConvention("spdeCD"))
```

Plotting the conditional simulations

```{r plot_cond_simu_spde, echo=TRUE, eval=TRUE}
p1 = plot.init(asp=1) + plot.raster(grid, name="spdeCD.Z.1", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD1")
p2 = plot.init(asp=1) + plot.raster(grid, name="spdeCD.Z.2", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD2")
p3 = plot.init(asp=1) + plot.raster(grid, name="spdeCD.Z.3", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD3")
p4 = plot.init(asp=1) + plot.raster(grid, name="spdeCD.Z.4", palette = "Spectral") + 
      plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "Simulation CD4")
ggarrange(p1, p2, p3, p4, ncol = 2, nrow = 2)
```

## Kriging

```{r kriging_spde, echo=TRUE, eval=TRUE}
err = grid$deleteColumns(names = c("spdeK*.Z.*"))
err = krigingSPDE(dbin = dat, dbout = grid, model = model, 
                  flag_est = TRUE, flag_std = TRUE,
                  namconv = NamingConvention("spdeK"))
```


```{r plot_kriging_spde, echo=TRUE, eval=TRUE}
p1 = plot.init(asp=1) + plot.raster(grid, name="spdeK.Z.estim", palette = "Spectral") +
        plot.symbol(dat, col = "red") + plot.decoration(title = "Estimation")
p2 = plot.init(asp=1) + plot.raster(grid, name="spdeK.Z.stdev", palette = "Spectral") +
        plot.symbol(dat, col = "black", size=0.1) + plot.decoration(title = "St. dev.")
ggarrange(p1, p2, ncol = 2, nrow = 2)
```

Correlation between traditional and SPDE method for kriging estimation values

```{r correl_kriging, echo=TRUE, eval=TRUE}
p = plot.init() + 
    plot.correlation(db1 = grid, 
                     namex = "standardK.Z.estim", 
                     namey = "spdeK.Z.estim", asPoint = FALSE, bins=100,
                     flagDiag = TRUE, diagColor = "red", flagSameAxes = FALSE) +
    plot.decoration(xlab = "Traditional", ylab = "SPDE", 
                  title = "Comparison for Kriging")
plot.end(p)
```

Correlation between traditional and SPDE method for kriging Standard deviation values

```{r correl_stdev, echo=TRUE, eval=TRUE}
p = plot.init() + 
    plot.correlation(db1 = grid, 
                     namex = "standardK.Z.stdev", 
                     namey = "spdeK.Z.stdev", asPoint = FALSE, bins=100,
                     flagDiag = TRUE, diagColor = "red", flagSameAxes = FALSE) +
    plot.decoration(xlab = "Traditional", ylab = "SPDE", 
                  title = "Comparison for St. Dev.")
plot.end(p)
```

Comparative statistics

```{r}
# statistics
knitr::kable(dbStatisticsMono(db = grid, names = "*.estim", opers = opers)$toTL(),
             digits = 3, caption = "Estimations")

knitr::kable(dbStatisticsMono(db = grid, names = "*.stdev", opers = opers)$toTL(),
             digits = 3, caption = "St. dev. of Estimation error")
```

Produce some auxiliary statistics for simulations

```{r}
knitr::kable(dbStatisticsMono(db = grid, names = "*NC.*", opers = opers)$toTL(),
             digits = 3, caption = "Non conditional simulations")
```


```{r}
knitr::kable(dbStatisticsMono(db = grid, names = "*CD.*", opers = opers)$toTL(),
             digits = 3, caption = "Conditional simulations")
```

# References

* Lindgren, F., Rue, H., and Lindström, J. (2011). An explicit link between gaussian fields and gaussian markov random fields: the spde approach (with discussion). JR 671 Stat Soc, Series B, 73:423–498.

* Pereira, M., Desassis, N., & Allard, D. (2022). Geostatistics for Large Datasets on Riemannian Manifolds: A Matrix-Free Approach. Journal of Data Science, 20(4), 512-532. doi:10.6339/22-JDS1075

